"""Compatibility with ouputs of Intranat."""
import csv
import os
import re
import logging

import numpy as np
import pandas as pd

from ..system.logging import set_log_level
from ..preprocessing.reference import (contact_bipo_to_mono, clean_contact,
                                       flat_bipolar_contact)

logger = logging.getLogger('brainpipe')


def intranat_csv(path, as_df=True, clean=True, channels=None, verbose=None):
    """Read csv files generated by intranat.

    Original version :
    https://github.com/IntrAnatSEEGSoftware/IntrAnat/blob/
    b101cdc09f4818f5c2c1d0b17295efb5ba647c3d/readElecLocalCSVFile.py

    Parameters
    ----------
    path : string
        Path to the csv file.
    as_df : bool | True
        Return dataframes instead of dict.
    clean : bool | True
        Clean contacts. Only works if `as_df` is True.
    """
    _, name = os.path.split(path)
    assert os.path.isfile(path), "Wrong path to the file %s" % name
    set_log_level(verbose)

    # Load and read the content of the file
    logger.info("Read anatomy %s" % name)
    data = csv.reader(open(path), delimiter='\t')
    contents = []
    for row in data:
        contents.append(row)

    # save_space = 0
    # Find the string 'contact' to identify the starting line
    for i1 in range(len(contents[1])):
        for i2 in range(10):
            try:
                if contents[i2][i1] == 'contact':
                    savec = i1
                    savel = i2
                # if contents[i2][i1] == 'Use of MNI Template':
                #     save_space = i2
            except:
                continue

    startl = savel + 1
    # Extract monopolar and bipolar contacts, assuming each list is separated
    # by a two-lines blank
    contacts_infos = {'monopolar': {}, 'bipolar': {}}
    i = -2
    for pol in ['monopolar', 'bipolar']:
        i = i + 2
        while (startl + i < len(contents)) and contents[startl + i]:
            # standard name : 'Ap12' (not A'12, Ap21, a'1a'2...)
            nametmp = contents[startl + i][savec].replace('-', ' - ')

            testpol = re.search("-", nametmp)
            if testpol is not None:
                polarity = 'bipolar'
            else:
                polarity = 'monopolar'

            if polarity == 'bipolar':  # test if it's A02-A01 or A01-A02
                assert ('-' in nametmp) and (len(nametmp) % 2 == 1)
                number = [int(n) for n in re.findall(r'\d+', nametmp)]
                if number[0] < number[1]:
                    # logger.warning('Contacts %s inverted' % nametmp)
                    nametmp = ' - '.join(list(reversed(nametmp.split(' - '))))

            if nametmp not in contacts_infos.keys():
                contacts_infos[polarity].update({nametmp: {}})

            for idx_col in contents[savel]:
                if idx_col != 'contact':
                    _d = {idx_col: contents[startl + i][contents[
                        savel].index(idx_col)]}
                    contacts_infos[polarity][nametmp].update(_d)

            i += 1

    resection_infos = {}
    i = i + 2
    try:
        while contents[startl + i]:
            if contents[startl + i] == ['Resection Information']:
                actual_atlas = ''
            elif contents[startl + i] == ['mars_atlas']:
                actual_atlas = 'mars_atlas'
                resection_infos.update({'mars_atlas': {}})
            elif contents[startl + i] == ['Freesurfer']:
                actual_atlas = 'Freesurfer'
                resection_infos.update({'Freesurfer': {}})
            elif contents[startl + i][0] == 'Volume resection (mm3):':
                _d = {'Volume resection (mm3):': contents[startl + i][1]}
                resection_infos.update(_d)
            else:
                _d = {contents[startl + i][0]: contents[startl + i][1]}
                resection_infos[actual_atlas].update(_d)
            i += 1
    except:
        pass

    # Dataframe transformation
    if as_df:
        logger.info('    - DataFrame conversion')
        # Contact info
        for k, d in contacts_infos.items():
            _df = pd.DataFrame(d).T.reset_index()
            _df.rename(columns={'index': 'contact'}, inplace=True)
            contacts_infos[k] = _df

        # Resection
        resection_infos = pd.DataFrame(resection_infos)

    # Dataframe cleaning
    if clean:
        assert as_df, "Cleaning only works if `as_df` is True"
        logger.info('    - Cleaning dataframes')
        # Replacing rules
        xyz_repl = {'\[': '', '\]': '', ',': '', ';': ''}
        for k, d in contacts_infos.items():
            # Replace string patterns
            d['contact'] = clean_contact(d['contact'])
            d['MNI'].replace(xyz_repl, regex=True, inplace=True)
            # Convert MNI strings to numeric
            _xyz_split = d['MNI'].str.split()
            d['X'] = pd.to_numeric(_xyz_split.str.get(0))
            d['Y'] = pd.to_numeric(_xyz_split.str.get(1))
            d['Z'] = pd.to_numeric(_xyz_split.str.get(2))

    # Dataframe reorganization
    if isinstance(channels, list):
        assert as_df, "Cleaning only works if `as_df` is True"
        logger.info('    - Reorganize dataframes according to a list of sites')

        # Get a clean monopolar version of the channels
        channels = clean_contact(channels)
        c_mono = contact_bipo_to_mono(channels)

        # Find index of corresponding monopolar channels
        idx_mono, bad_mono = [], []
        mono_anat_channels = list(contacts_infos['monopolar']['contact'])
        for k in c_mono:
            if k in mono_anat_channels:
                idx_mono += [mono_anat_channels.index(k)]
            else:
                bad_mono += [k]

        contacts_infos['monopolar'] = contacts_infos['monopolar'].loc[
            idx_mono].reset_index()

        # Find index of corresponding bipolar channels
        bipo_anat_channels = list(contacts_infos['bipolar']['contact'])
        bipo_anat_channels = flat_bipolar_contact(bipo_anat_channels)
        c_bipo = flat_bipolar_contact(channels)
        idx_bipo, bad_bipo = [], []
        for k in c_bipo:
            if k in bipo_anat_channels:
                idx_bipo += [bipo_anat_channels.index(k)]
            else:
                bad_bipo += [k]
        contacts_infos['bipolar'] = contacts_infos['bipolar'].loc[
            idx_bipo].reset_index()

        # Merge bad bipo / mono contact
        l_ = abs(len(bad_bipo) - len(bad_mono))
        if len(bad_bipo) < len(bad_mono):
            bad_bipo += [''] * l_
        elif len(bad_bipo) > len(bad_mono):
            bad_mono += [''] * l_
        contacts_infos['ignored'] = pd.DataFrame(dict(Monopolar=bad_mono,
                                                      Bipolar=bad_bipo))

    return (contacts_infos, resection_infos)


def intranat_save_anat(df_contact, save_as, df_resection=None):
    """Save the dataframe generated by intranat.

    Parameters
    ----------
    df : DataFrame
        The pandas DataFrame generated by the function `intranat_csv`
    save_as : string
        The full path to the xlsx file.
    df_resection : DataFrame | None
        The pandas DataFrame containing the resection informations.
    """
    assert isinstance(df_contact, pd.DataFrame)
    writer = pd.ExcelWriter(save_as)
    df_contact['bipolar'].to_excel(writer, 'Bipolar')
    df_contact['monopolar'].to_excel(writer, 'Monopolar')
    df_contact['ignored'].to_excel(writer, 'Ignored')
    if isinstance(df_resection, pd.DataFrame):
        df_resection.to_excel(writer, 'Resection')
    writer.save()


def intranat_load_anat(path, polarity='bipolar'):
    """Load an anatomical excel file generated by `intranat_save_anat`.

    Parameters
    ----------
    path : string
        Path or list of path to anatomical excel files
    polarity : {'monopolar', 'bipolar'}
        The polarity to load. By default, the bipolar one is loaded

    Returns
    -------
    df : DataFrame
        The pandas DataFrame for the selected polarity
    """
    assert polarity in ['bipolar', 'monopolar']
    def load_df(f):  # noqa
        logger.info('Loading %s' % f)
        return pd.read_excel(f, sheet_name=polarity.capitalize())
    if isinstance(path, (list, tuple)):
        assert all([os.path.isfile(k) for k in path])
        df = []
        for f in path:
            suj = os.path.splitext(os.path.split(f)[1])[0]
            _df = load_df(f)
            _df['Subject'] = [suj] * len(_df)
            df += [_df]
        df = intranat_merge_anatomy(df)
    else:
        assert os.path.isfile(path)
        df = load_df(path)
    return df


def intranat_merge_anatomy(df_lst):
    """Merge a list of anatomical dataframes.

    Parameters
    ----------
    df_lst : list
        List of anatomical dataframes

    Returns
    -------
    df : DataFrame
        Merged pandas DataFrame
    """
    assert isinstance(df_lst, (list, tuple))
    assert all([isinstance(k, pd.DataFrame) for k in df_lst])
    for num, df in enumerate(df_lst):
        if 'index' in df.keys():
            df_lst[num].drop('index', axis=1, inplace=True)
    return pd.concat(df_lst, ignore_index=False, join='inner').reset_index()


def intranat_group_anatomy(df, save_as, groupby='MarsAtlas'):
    """Group the anatomy of multiple anatomical files.

    Parameters
    ----------
    df : DataFrame
        DataFrame or list of anatomical dataframes
    save_as : string
        Name of the grouped dataframe to save
    """
    if isinstance(df, (list, tuple)):
        df = intranat_merge_anatomy(df)
    assert isinstance(df, pd.DataFrame)
    assert groupby in df.keys()
    if groupby == 'MarsAtlas':
        df.replace(dict(R_='', L_=''), inplace=True, regex=True)
    writer = pd.ExcelWriter(save_as)
    for k, idx in df.groupby(groupby).groups.items():
        df_gp = df.iloc[idx].reset_index(drop=True)
        df_gp.to_excel(writer, k)
    writer.save()


def _find_in_df(df, col, pat):
    if col is None or pat is None:
        return np.ones((len(df),), dtype=bool)
    is_inside = np.zeros((len(df), len(pat)), dtype=bool)
    for num, k in enumerate(pat):
        is_inside[:, num] = df[col] == k
    return is_inside.any(axis=1)


def intranat_get_roi(df, roi, segmentation='MarsAtlas', polarity='bipolar'):
    """Get contact name and index that are contained inside an ROI.

    Parameters
    ----------
    df : pd.DataFrame
        The dataframe or a list of dataframes saved using `intranat_save_anat`
    roi : string
        The name of the ROI to get or a list of ROIs
    segmentation : string
        The column name of the segmentation to use ('MarsAtlas' or
        'Freesurfer'...)
    polarity : {'bipolar', 'monopolar'}
        The contact polarity to get

    Returns
    -------
    df_roi : DataFrame
        The pandas DataFrame with the ROI informations
    idx_roi : array_like
        The index of the channel that are inside this ROI
    """
    assert polarity in ['monopolar', 'bipolar']
    # assert segmentation in ['MarsAtlas', 'Freesurfer']

    if isinstance(df, (list, tuple)):
        is_path = all([os.path.isfile(k) for k in df])
        if is_path:
            df = intranat_load_anat(df, polarity)
        else:
            df = intranat_merge_anatomy(df)
    if segmentation == 'MarsAtlas':
        df.replace(dict(R_='', L_=''), inplace=True, regex=True)
    is_inside = _find_in_df(df, segmentation, roi)
    df_roi = df.iloc[is_inside].reset_index(drop=True)
    idx_roi = np.arange(len(df))[is_inside]
    return df_roi, idx_roi
