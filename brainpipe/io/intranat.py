"""Compatibility with ouputs of Intranat."""
import csv
import os
import re
import logging

import pandas as pd

from ..system.logging import set_log_level
from ..preprocessing.reference import (contact_bipo_to_mono, clean_contact,
                                       flat_bipolar_contact)

logger = logging.getLogger('brainpipe')


def intranat_db_integrity(path):
    """Check a database of intracranial files integrity."""
    pass


def intranat_csv(path, as_df=True, clean=True, channels=None, verbose=None):
    """Read csv files generated by intranat.

    Original version :
    https://github.com/IntrAnatSEEGSoftware/IntrAnat/blob/
    b101cdc09f4818f5c2c1d0b17295efb5ba647c3d/readElecLocalCSVFile.py

    Parameters
    ----------
    path : string
        Path to the csv file.
    as_df : bool | True
        Return dataframes instead of dict.
    clean : bool | True
        Clean contacts. Only works if `as_df` is True.
    """
    _, name = os.path.split(path)
    assert os.path.isfile(path), "Wrong path to the file %s" % name
    set_log_level(verbose)

    # Load and read the content of the file
    logger.info("Read anatomy %s" % name)
    data = csv.reader(open(path), delimiter='\t')
    contents = []
    for row in data:
        contents.append(row)

    # save_space = 0
    # Find the string 'contact' to identify the starting line
    for i1 in range(len(contents[1])):
        for i2 in range(10):
            try:
                if contents[i2][i1] == 'contact':
                    savec = i1
                    savel = i2
                # if contents[i2][i1] == 'Use of MNI Template':
                #     save_space = i2
            except:
                continue

    startl = savel + 1
    # Extract monopolar and bipolar contacts, assuming each list is separated
    # by a two-lines blank
    contacts_infos = {'monopolar': {}, 'bipolar': {}}
    i = -2
    for pol in ['monopolar', 'bipolar']:
        i = i + 2
        while (startl + i < len(contents)) and contents[startl + i]:
            # standard name : 'Ap12' (not A'12, Ap21, a'1a'2...)
            nametmp = contents[startl + i][savec].replace('-', ' - ')

            testpol = re.search("-", nametmp)
            if testpol is not None:
                polarity = 'bipolar'
            else:
                polarity = 'monopolar'

            if polarity == 'bipolar':  # test if it's A02-A01 or A01-A02
                assert ('-' in nametmp) and (len(nametmp) % 2 == 1)
                number = [int(n) for n in re.findall(r'\d+', nametmp)]
                if number[0] < number[1]:
                    # logger.warning('Contacts %s inverted' % nametmp)
                    nametmp = ' - '.join(list(reversed(nametmp.split(' - '))))

            if nametmp not in contacts_infos.keys():
                contacts_infos[polarity].update({nametmp: {}})

            for idx_col in contents[savel]:
                if idx_col != 'contact':
                    _d = {idx_col: contents[startl + i][contents[
                        savel].index(idx_col)]}
                    contacts_infos[polarity][nametmp].update(_d)

            i += 1

    resection_infos = {}
    i = i + 2
    try:
        while contents[startl + i]:
            if contents[startl + i] == ['Resection Information']:
                actual_atlas = ''
            elif contents[startl + i] == ['mars_atlas']:
                actual_atlas = 'mars_atlas'
                resection_infos.update({'mars_atlas': {}})
            elif contents[startl + i] == ['Freesurfer']:
                actual_atlas = 'Freesurfer'
                resection_infos.update({'Freesurfer': {}})
            elif contents[startl + i][0] == 'Volume resection (mm3):':
                _d = {'Volume resection (mm3):': contents[startl + i][1]}
                resection_infos.update(_d)
            else:
                _d = {contents[startl + i][0]: contents[startl + i][1]}
                resection_infos[actual_atlas].update(_d)
            i += 1
    except:
        pass

    # Dataframe transformation
    if as_df:
        logger.info('    - DataFrame conversion')
        # Contact info
        for k, d in contacts_infos.items():
            _df = pd.DataFrame(d).T.reset_index()
            _df.rename(columns={'index': 'contact'}, inplace=True)
            contacts_infos[k] = _df

        # Resection
        resection_infos = pd.DataFrame(resection_infos)

    # Dataframe cleaning
    if clean:
        assert as_df, "Cleaning only works if `as_df` is True"
        logger.info('    - Cleaning dataframes')
        # Replacing rules
        xyz_repl = {'\[': '', '\]': '', ',': '', ';': ''}
        for k, d in contacts_infos.items():
            # Replace string patterns
            d['contact'] = clean_contact(d['contact'])
            d['MNI'].replace(xyz_repl, regex=True, inplace=True)
            # Convert MNI strings to numeric
            _xyz_split = d['MNI'].str.split()
            d['X'] = pd.to_numeric(_xyz_split.str.get(0))
            d['Y'] = pd.to_numeric(_xyz_split.str.get(1))
            d['Z'] = pd.to_numeric(_xyz_split.str.get(2))

    # Dataframe reorganization
    if isinstance(channels, list):
        assert as_df, "Cleaning only works if `as_df` is True"
        logger.info('    - Reorganize dataframes according to a list of sites')

        # Get a clean monopolar version of the channels
        channels = clean_contact(channels)
        c_mono = contact_bipo_to_mono(channels)

        # Find index of corresponding monopolar channels
        idx_mono, bad_mono = [], []
        mono_anat_channels = list(contacts_infos['monopolar']['contact'])
        for k in c_mono:
            if k in mono_anat_channels:
                idx_mono += [mono_anat_channels.index(k)]
            else:
                bad_mono += [k]

        contacts_infos['monopolar'] = contacts_infos['monopolar'].loc[
            idx_mono].reset_index()

        # Find index of corresponding bipolar channels
        bipo_anat_channels = list(contacts_infos['bipolar']['contact'])
        bipo_anat_channels = flat_bipolar_contact(bipo_anat_channels)
        c_bipo = flat_bipolar_contact(channels)
        idx_bipo, bad_bipo = [], []
        for k in c_bipo:
            if k in bipo_anat_channels:
                idx_bipo += [bipo_anat_channels.index(k)]
            else:
                bad_bipo += [k]
        contacts_infos['bipolar'] = contacts_infos['bipolar'].loc[
            idx_bipo].reset_index()

        # Merge bad bipo / mono contact
        l_ = abs(len(bad_bipo) - len(bad_mono))
        if len(bad_bipo) < len(bad_mono):
            bad_bipo += [''] * l_
        elif len(bad_bipo) > len(bad_mono):
            bad_mono += [''] * l_
        contacts_infos['ignored'] = pd.DataFrame(dict(Monopolar=bad_mono,
                                                      Bipolar=bad_bipo))

    return (contacts_infos, resection_infos)
